#2.0 What is a Server

*서버란 무엇일까? 접속을 받아주는 무언가
-서버는 컴퓨터이다. 인터넷에 연결된 컴퓨터이다.
소프트웨어적 서버는 인터넷에 연결된 한 덩어리의 코드이다. 
하나는 물리적으로 늘켜져 있는 컴퓨터 라는 의미
다른의미로는내접속에 요청을 응답하는 컴퓨터이다.


#2.1 What is Express

express는 프레임워크이다.
아주많은 코드로 우리가  쉽게 이용할수있게만들어준것이다.
Express로 할수있는것은 몇줄로 서버로 만들수 있다.
이미 많은줄로 만들어져있어서 빨리 만들수있다.
Django,lalabel,Express:서버를 만들어주는 프레임워크이다.

우리가 Express를 사용하는 이유는 안정적이고 매우 유명하기때문이다.
첨단기술이아니다 새로운버전이아니다. -이러한말은 엄청안정적이고 거의 완성되었다는 뜻이다.
 
#2.2 Installing Express with NPM

npm=node package manager
express같은걸 만들고 공유하기 위해서 다운로드 링크를 만드는방법이 있고 파일을 복사에서
프로젝트 디렉토리에 붙여넣는 방법이있다. 하지만 좋은방법이 아니기 때문에
중앙집중화된 개념이다. node.js와 관련된사람들이 각자의 패키지를 집어넣어놓는다.
그리고 우리가 다운받을것을 넣어둔다.
여기서 다운받고 여기서 업데이트가 가능하다.
express는 월 12백만회 다운로드 되었다.
react는 월 32만회, react native,electron도 있다.

npm으로 프로젝트를 시작하려면 package manager로 사용하려면 npm이 정한방식으로 
시작해야한다.
-> npm init
npm init을 하게되면 package.json파일이 생성된다.
Json은 자바스크립트에서 정보를 담는 방식이다.

npm install express- express를 이 디렉토리 안에 설치한다.
설치하게 되면 package-lock.json과 node_modules가 설치된다. dpdencies가 추가된다.
package가 살아남는 방법이다.

package-lock.json: 신경쓰지말자
node_modules: 우리가 막 다운로드 받은거다 npm을 통해 다운받은것이다.

추가로 기억할것
package.json을 갖는것은 매우좋은일이다.(협업할때) 왜냐면 node_module을 일일이 줄필요가 없기 때문이다.



#2.3 Your First Express Server
.gitignore- 깃에 올리고싶은것만 올릴수 있게해주는 파일이다.
package-lock.json:package에 security이 관련되어있다.

Expressjs.com에 들어가서 Routing에 있는 문구를 복사 붙여넣기한다.
require의 뜻은 어디선가 node-module을 가져오는 것이다.
이경우에는 express라는이름의 폴더를 내파일속에서 찾으려고한다.
만약없으면 node_module에서 찾는다.
node-js에 장점 :모든것이 블럭단위로 구성되어있음 설치-require-import하면된다.

const express =require("express");	//express를 import하기
const app = express();		//app 변수를 선언해서 express를 실행하기

index.js를 node로 실행하고싶지않어서 package.json을 중앙 컨트롤 타워로 만들것이다.
내 app이 해야할것을 package.json에 넣을것이다.
package.json에 scripts부분에다가 "start": "node index.js"라고 입력을 해놓으면 npm start만으로도 서버를 실행할수 있다.



 #2.4 Handling Routes with Express

http,브라우저의 동작 방식
인터넷에서는 두개의 주요한 동사가 있는데
하나는GET, 하나는 POST이다.
내가 웹사이트에가면 URL을 적는데 브라우저가GetMethod를 실행한다. 기본적으로 브라우저가 페이지를 읽어온다.
우리가 로그인을 하게되면 POST method를 이용해서 브라우저가 정보를 전달한다.

request는 있는데 뭔가 응답을 하게 해야한다.
일반적으로 서버가 하는 일은 HTML로 응답하게 하는것이다.
뭔가 응답하게 하는 방법은 쉽다. 이게 express가 늘 하는일이기도 하다.

만약에 함수가 이렇게 존재한다면 function handleExmple(req,res){}
request object ,response object
request object:우리가 정보를 얻고자하면 누가 페이지를 요청했나 어떤종류의 데이터가 페이지에 전송되었나 알아낼때
예를 들어, 아이디와 패스워드를 전송하면 POST방식으로 전송한다면 서버에는 request object로  그정보를 알아낼수있다.

app.get("", something)메소드는 인자가 두개 들어간다. 
첫번쨰에는 주소가 들어가고
두번쨰에는 그것을 실행할 함수가 들어간다.
서버를 ES6로 만들것이다.



#2.5 ES6 on NodeJS using Babel

Babel이란 무엇일까?
기본적으로 바벨은 최신의 javascript코드들의 예전의 무난한 javascript코드들로 바꿔준다.
왜바꾸냐면 브라우저에서는 최신의 javascript코드들을 이해 못할때가 있기 때문이다.
바벨은 여러가지 방법으로 사용이 가능한데 많은 loader가 있다.
우리가 사용할 방법은 Babel node이다 .
다운하는 방법은-
npm install @babel/node

또Babel이 가지고 있는게있는데 Stage를 가지거 있다. stage3이면 브라우저한테 절반만 받아들여 질것이다..
만약 stage0을 사용하게 된다면 완전히 실험적인걸 얻게 될것이다.

우리가 사용할 것은 -env이다. 가장 최신버전이고 실험적인 버전은 아니다.
다운하는 방법은-
npm install @babel/preset-env

만약 React를 한다면 다른preset이 있다. 왜냐면 Babel도 우선 React가 어떻게 작동하는지 알아야 하기 때문이다.
우리는 .babelrc파일에 우리가 원하는 node.js와 JS와 관련된 필요한것들, 설정을 다 집어 넣을것이다.
.bablerc 파일은 우리가 작업하고 있는 디렉토리에다가 만들면된다.

*Babel의 동작과정
1.Babel이 실행되기 전에 .babelrc파일을 찾아보고
2.babelrc파일에 설정해둔 Preset을 읽고
3.이해한다.

*.babelrc 파일의 내용
{
  "presets": ["@babel/preset-env"]
}
*작동하는지 테스트해보려면?
1 .const express = require('express'); 대신에 최신의 js버전인 import express from "express";
(둘은 같은내용이다.)
2. package.json에다가 "scripts": node index.js를 babel-node index.js로 바꾼다.
3. 이렇게 실행 하게된다면 바벨이 못생긴 코드로 바꾸게 될것이다.
4. 그런다음 node.js로 실행 할것이다.
이렇게 하면 이런에러가 뜨는데
Cannot find module '@babel/core'
그러면 npm install @babel/core를 해주면된다.

화살표 함수를 이해해보자
-함수란 무엇일까? 함수는 원하는 작업을 수행하기 위해만들어 놓은 코드 블록이다.
ES6이전에 함수를 표현하는 방법에는 무엇이있을까>
1.함수 선언
function foo(){} 

2.함수 표현식
const foo = function(){}
함수의 이름이 없는 익명함수를 변수에 할당하는 방식이다.

화살표함수는 왜쓸까?
함수를 표현해지는것이 간단해지기 때문에 사용한다.
그리고 화살표 함수는 항상 익명함수이다.

1. function 키워드를 생략할 수있다.
2. 함수의 매개변수가 1개라면 괄호()를 생략할수 있다.
3. 함수 바디가 표현식 하나라면 중괄호와 return 문을 생략할수 있다.

function handleProfile(req, res) {
   res.send("you are on my profile");
 }
const handleProfile = (req, res) =>
 res.send("you are on my profile");
로 바꿀수있다.

만약에 project에 필요한 것(depedencies)에 추가되는것 말고 개발자로 살면서 필요한것들을 
npm에서 install할때는 npm install ~~ -D를 사용하면된다.
그렇게되면 package.json파일에 "devDependencies"에 추가 된다.

nodemon: node.js소스 수정시 자동으로 서버를 재시작해주는 프로그램
nodemon이라는 패키지를 설치할것이다. 
그래서 npm install nodemon -D를 해준다 그리고 script에 babel-node index.js를 
nodemon --exec babel-node index.js로 수정해준다.


#2.6 Express Core: Middlewares

*내가 일단 저장하고 재시작하면 Babel node가 감지하고 재시작해서 두번 실행되는것이다.
scripts: "start": "nodemon --exec babel-node index.js --delay 2"
--delay 2를 뒤에 붙이게 된다면 2초뒤에 시작한다.

*express를 할때 middleware라는 이름의 녀석을 알아야한다. 어려운 express의 내용이다.
middleware:처리가 끝날때까지 연결되어있는것이다. 유저와 마지막 응답사이에 있는것이다.

*middleware 함수들은 매개변수를 원래가지는것 (req, res) 말고도 하나를 더가진다. (req,res,next).
다른함수들은 보통은 매개변수로 next를 가지지 않는다. 왜냐하면 마지막으로 도달하는 함수이기 때문이다.

*MiddleWare의 예시
const betweenHome = (req, res, next) => {
  console.log("I'm between");
  next();		//next를 호출해야 매개변수로 들어간 인자인 handleHome을 호출할수있다.
};
middleware는 내가 원하는만큼 가질수있다. 파일을 전송할때 중간에서 가로챌수도있다. 모든접속에대한 로그를 작성하는 
미들웨어도 작성할수이따.


app.use(betweenHome);
미들웨어를 사용할건데 웹사이트에서 일어나는 모든것에 대해 적용한다.

express에서는 문장의 순서가 중요하다
접속이 있으면 위에서 아래로 실행한다. 미들웨어를 제일 위에다 넣어야지 반환해서 돌아오기 떄문에
제일위에다가 작성하는 것이 좋다.

#2.7 Express Core: Middlewares part Two

Morgan이라는 middleware를 설치해보자
-npm install morgan
logging에 도움을 주는 middleware이다:로깅이란 어디서 무슨일이 일어났는지이다.
설치하고 해야할 일들
1.이렇게 다운을 받게되면 package.json파일에 depedency부분에 추가된다 
2.js파일에다가 import 해줘야한다.
-import morgan from "morgan";
3.인자와 함께 사용한다. 미들웨어로 morgan을 tiny라는 인자를 이용해서
-app.use(morgan("tiny")); 

이외에도 많은 미들웨어가 있다. 

우리는 helmet이라는 middleware를 설치해보자
-npm install helmet
node.js의 안전성을 추가해준다(보안)

*middleware로 연결을 끊어버리는방법
middleware가  route전에 response를 보낸다면  연결이 일어나지 못한다.

cookie-parser와 body-parser도 설치할것이다.
-npm install body-parser
-npm install cookie-parser
cookie와body를 다루는 것을 도와준다.
body로부터 정보를 얻을수 있게도와준다.
cookie에 유저정보를 저장할것이다 session을 다루기 위해서
기본적으로 form을 채워서 나에게 전송한다면 서버를 의해서  특정한형태로 받아져야만한다.
내가 하려는건 form을 받으면 그데이터를 갖고있는 request object에 접근하기 원한다.

body-parser에는 정의해야하는 옵션이 있다. json,text,urlencoded
우리가 무엇을 전송해야하는지 알아야하기 때문이다.
이게 서버가 유저로부터 받은정보를 이해하는 과정이다.
사용예시
app.use(bodyParser.json());
app.use(bodyParser.urlencode({ extended: true }));


